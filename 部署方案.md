# 阅迹（ReadTrip）多用户部署方案

## 需求分析

1. ✅ 用户登录功能
2. ✅ 不同用户可以记录自己的书籍
3. ✅ 用户只能看到自己的书籍记录
4. ✅ 管理员可以看到所有用户的书籍记录

## 推荐方案：Supabase + Vercel/Netlify

### 为什么选择这个方案？

1. **项目已集成 Supabase**：无需引入新的技术栈
2. **Supabase 提供完整解决方案**：
   - 用户认证（Auth）
   - 数据库（PostgreSQL）
   - 行级安全策略（RLS）实现权限控制
   - 实时数据同步
3. **部署简单**：前端可部署到 Vercel/Netlify，免费且自动化
4. **成本低**：Supabase 免费版足够中小型应用使用

---

## 实施步骤

### 第一步：Supabase 数据库设计

#### 1.1 创建用户表（Supabase 自动提供）
Supabase 会自动创建 `auth.users` 表，无需手动创建。

#### 1.2 创建阅读记录表

在 Supabase Dashboard 的 SQL Editor 中执行：

```sql
-- 创建阅读记录表
CREATE TABLE reading_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  book_title TEXT NOT NULL,
  book_author TEXT NOT NULL,
  book_cover_url TEXT,
  book_genre TEXT,
  book_country TEXT NOT NULL,
  book_country_code TEXT NOT NULL,
  start_date DATE,
  end_date DATE,
  review TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 创建索引以提高查询性能
CREATE INDEX idx_reading_records_user_id ON reading_records(user_id);
CREATE INDEX idx_reading_records_country_code ON reading_records(book_country_code);
CREATE INDEX idx_reading_records_created_at ON reading_records(created_at DESC);

-- 创建更新时间触发器
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_reading_records_updated_at
  BEFORE UPDATE ON reading_records
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

#### 1.3 创建管理员表（可选）

如果需要管理员功能，可以创建一个管理员表：

```sql
-- 创建管理员表
CREATE TABLE admins (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 插入你的用户ID作为管理员（需要先注册账号后获取user_id）
-- INSERT INTO admins (user_id) VALUES ('你的用户ID');
```

#### 1.4 设置行级安全策略（RLS）

```sql
-- 启用 RLS
ALTER TABLE reading_records ENABLE ROW LEVEL SECURITY;

-- 策略1：用户只能查看自己的记录
CREATE POLICY "Users can view their own records"
  ON reading_records
  FOR SELECT
  USING (auth.uid() = user_id);

-- 策略2：用户只能插入自己的记录
CREATE POLICY "Users can insert their own records"
  ON reading_records
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- 策略3：用户只能更新自己的记录
CREATE POLICY "Users can update their own records"
  ON reading_records
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- 策略4：用户只能删除自己的记录
CREATE POLICY "Users can delete their own records"
  ON reading_records
  FOR DELETE
  USING (auth.uid() = user_id);

-- 策略5：管理员可以查看所有记录（如果有管理员表）
CREATE POLICY "Admins can view all records"
  ON reading_records
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM admins
      WHERE admins.user_id = auth.uid()
    )
  );
```

---

### 第二步：更新前端代码

#### 2.1 创建认证 Hook

创建 `src/hooks/useAuth.ts`：

```typescript
import { useState, useEffect } from 'react';
import { User } from '@supabase/supabase-js';
import { supabase } from '@/integrations/supabase/client';

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 获取当前用户
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // 监听认证状态变化
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    return () => subscription.unsubscribe();
  }, []);

  const signIn = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    return { data, error };
  };

  const signUp = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    });
    return { data, error };
  };

  const signOut = async () => {
    await supabase.auth.signOut();
  };

  return {
    user,
    loading,
    signIn,
    signUp,
    signOut,
  };
}
```

#### 2.2 创建管理员检查 Hook

创建 `src/hooks/useAdmin.ts`：

```typescript
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from './useAuth';

export function useAdmin() {
  const { user } = useAuth();
  const [isAdmin, setIsAdmin] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setIsAdmin(false);
      setLoading(false);
      return;
    }

    // 检查用户是否是管理员
    const checkAdmin = async () => {
      const { data, error } = await supabase
        .from('admins')
        .select('user_id')
        .eq('user_id', user.id)
        .single();

      setIsAdmin(!!data && !error);
      setLoading(false);
    };

    checkAdmin();
  }, [user]);

  return { isAdmin, loading };
}
```

#### 2.3 更新 useReadingRecords Hook

将 `src/hooks/useReadingRecords.ts` 改为从 Supabase 读取数据：

```typescript
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { ReadingRecord, CountryData } from '@/types/reading';
import { useAuth } from './useAuth';
import { useAdmin } from './useAdmin';

export function useReadingRecords() {
  const { user } = useAuth();
  const { isAdmin } = useAdmin();
  const [records, setRecords] = useState<ReadingRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // 从 Supabase 加载数据
  useEffect(() => {
    if (!user) {
      setRecords([]);
      setIsLoading(false);
      return;
    }

    const loadRecords = async () => {
      try {
        setIsLoading(true);
        
        // 构建查询
        let query = supabase
          .from('reading_records')
          .select('*')
          .order('created_at', { ascending: false });

        // 如果不是管理员，只查询自己的记录
        if (!isAdmin) {
          query = query.eq('user_id', user.id);
        }

        const { data, error } = await query;

        if (error) {
          console.error('Failed to load reading records:', error);
          return;
        }

        // 转换数据格式
        const formattedRecords: ReadingRecord[] = (data || []).map((row) => ({
          id: row.id,
          book: {
            id: row.id,
            title: row.book_title,
            author: row.book_author,
            coverUrl: row.book_cover_url,
            genre: row.book_genre,
            country: row.book_country,
            countryCode: row.book_country_code,
          },
          startDate: row.start_date,
          endDate: row.end_date,
          review: row.review,
          createdAt: row.created_at,
        }));

        setRecords(formattedRecords);
      } catch (error) {
        console.error('Failed to load reading records:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadRecords();
  }, [user, isAdmin]);

  // 添加记录
  const addRecord = useCallback(
    async (record: Omit<ReadingRecord, 'id' | 'createdAt'>) => {
      if (!user) {
        throw new Error('User not authenticated');
      }

      const { data, error } = await supabase
        .from('reading_records')
        .insert({
          user_id: user.id,
          book_title: record.book.title,
          book_author: record.book.author,
          book_cover_url: record.book.coverUrl,
          book_genre: record.book.genre,
          book_country: record.book.country,
          book_country_code: record.book.countryCode,
          start_date: record.startDate || null,
          end_date: record.endDate || null,
          review: record.review || null,
        })
        .select()
        .single();

      if (error) {
        console.error('Failed to add record:', error);
        throw error;
      }

      // 更新本地状态
      const newRecord: ReadingRecord = {
        id: data.id,
        book: {
          id: data.id,
          title: data.book_title,
          author: data.book_author,
          coverUrl: data.book_cover_url,
          genre: data.book_genre,
          country: data.book_country,
          countryCode: data.book_country_code,
        },
        startDate: data.start_date,
        endDate: data.end_date,
        review: data.review,
        createdAt: data.created_at,
      };

      setRecords((prev) => [newRecord, ...prev]);
      return newRecord;
    },
    [user]
  );

  // 批量添加记录
  const addRecords = useCallback(
    async (newRecords: Array<Omit<ReadingRecord, 'id' | 'createdAt'>>) => {
      if (!user) {
        throw new Error('User not authenticated');
      }

      const recordsToInsert = newRecords.map((record) => ({
        user_id: user.id,
        book_title: record.book.title,
        book_author: record.book.author,
        book_cover_url: record.book.coverUrl,
        book_genre: record.book.genre,
        book_country: record.book.country,
        book_country_code: record.book.countryCode,
        start_date: record.startDate || null,
        end_date: record.endDate || null,
        review: record.review || null,
      }));

      const { data, error } = await supabase
        .from('reading_records')
        .insert(recordsToInsert)
        .select();

      if (error) {
        console.error('Failed to add records:', error);
        throw error;
      }

      // 更新本地状态
      const formattedRecords: ReadingRecord[] = (data || []).map((row) => ({
        id: row.id,
        book: {
          id: row.id,
          title: row.book_title,
          author: row.book_author,
          coverUrl: row.book_cover_url,
          genre: row.book_genre,
          country: row.book_country,
          countryCode: row.book_country_code,
        },
        startDate: row.start_date,
        endDate: row.end_date,
        review: row.review,
        createdAt: row.created_at,
      }));

      setRecords((prev) => [...formattedRecords, ...prev]);
      return formattedRecords;
    },
    [user]
  );

  // 删除记录
  const deleteRecord = useCallback(async (id: string) => {
    const { error } = await supabase
      .from('reading_records')
      .delete()
      .eq('id', id);

    if (error) {
      console.error('Failed to delete record:', error);
      throw error;
    }

    setRecords((prev) => prev.filter((r) => r.id !== id));
  }, []);

  // 更新记录
  const updateRecord = useCallback(
    async (id: string, updates: Partial<ReadingRecord>) => {
      const updateData: any = {};

      if (updates.book) {
        updateData.book_title = updates.book.title;
        updateData.book_author = updates.book.author;
        updateData.book_cover_url = updates.book.coverUrl;
        updateData.book_genre = updates.book.genre;
        updateData.book_country = updates.book.country;
        updateData.book_country_code = updates.book.countryCode;
      }

      if (updates.startDate !== undefined) {
        updateData.start_date = updates.startDate || null;
      }
      if (updates.endDate !== undefined) {
        updateData.end_date = updates.endDate || null;
      }
      if (updates.review !== undefined) {
        updateData.review = updates.review || null;
      }

      const { error } = await supabase
        .from('reading_records')
        .update(updateData)
        .eq('id', id);

      if (error) {
        console.error('Failed to update record:', error);
        throw error;
      }

      setRecords((prev) =>
        prev.map((record) =>
          record.id === id ? { ...record, ...updates } : record
        )
      );
    },
    []
  );

  // 清除所有记录
  const clearAllRecords = useCallback(async () => {
    if (!user) return;

    const { error } = await supabase
      .from('reading_records')
      .delete()
      .eq('user_id', user.id);

    if (error) {
      console.error('Failed to clear records:', error);
      throw error;
    }

    setRecords([]);
  }, [user]);

  // 获取按国家分组的数据
  const getCountryData = useCallback((): CountryData[] => {
    const countryMap = new Map<string, CountryData>();

    records.forEach((record) => {
      const code = record.book.countryCode.toUpperCase();
      if (!countryMap.has(code)) {
        countryMap.set(code, {
          code,
          name: record.book.country,
          nameCn: record.book.country,
          books: [],
        });
      }
      countryMap.get(code)!.books.push(record);
    });

    return Array.from(countryMap.values());
  }, [records]);

  // 获取已访问的国家代码列表
  const getVisitedCountries = useCallback((): string[] => {
    return [...new Set(records.map((r) => r.book.countryCode.toUpperCase()))];
  }, [records]);

  // 获取统计数据
  const getStats = useCallback(() => {
    const countries = getVisitedCountries();
    return {
      totalBooks: records.length,
      totalCountries: countries.length,
      countries,
    };
  }, [records, getVisitedCountries]);

  return {
    records,
    isLoading,
    addRecord,
    addRecords,
    deleteRecord,
    updateRecord,
    clearAllRecords,
    getCountryData,
    getVisitedCountries,
    getStats,
  };
}
```

#### 2.4 创建登录/注册组件

创建 `src/components/AuthDialog.tsx`：

```typescript
import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useAuth } from '@/hooks/useAuth';
import { toast } from 'sonner';

interface AuthDialogProps {
  isOpen: boolean;
  onClose: () => void;
}

export function AuthDialog({ isOpen, onClose }: AuthDialogProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const { signIn, signUp } = useAuth();

  const handleSignIn = async () => {
    if (!email || !password) {
      toast.error('请填写邮箱和密码');
      return;
    }

    setLoading(true);
    try {
      const { error } = await signIn(email, password);
      if (error) {
        toast.error(error.message);
      } else {
        toast.success('登录成功');
        onClose();
      }
    } catch (error) {
      toast.error('登录失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };

  const handleSignUp = async () => {
    if (!email || !password) {
      toast.error('请填写邮箱和密码');
      return;
    }

    if (password.length < 6) {
      toast.error('密码至少需要6个字符');
      return;
    }

    setLoading(true);
    try {
      const { error } = await signUp(email, password);
      if (error) {
        toast.error(error.message);
      } else {
        toast.success('注册成功！请检查邮箱验证链接');
        onClose();
      }
    } catch (error) {
      toast.error('注册失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>登录 / 注册</DialogTitle>
        </DialogHeader>
        <Tabs defaultValue="signin" className="w-full">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="signin">登录</TabsTrigger>
            <TabsTrigger value="signup">注册</TabsTrigger>
          </TabsList>
          <TabsContent value="signin" className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">邮箱</Label>
              <Input
                id="email"
                type="email"
                placeholder="your@email.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">密码</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <Button onClick={handleSignIn} disabled={loading} className="w-full">
              {loading ? '登录中...' : '登录'}
            </Button>
          </TabsContent>
          <TabsContent value="signup" className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email-signup">邮箱</Label>
              <Input
                id="email-signup"
                type="email"
                placeholder="your@email.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password-signup">密码（至少6个字符）</Label>
              <Input
                id="password-signup"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <Button onClick={handleSignUp} disabled={loading} className="w-full">
              {loading ? '注册中...' : '注册'}
            </Button>
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}
```

#### 2.5 更新主页面添加登录功能

在 `src/pages/Index.tsx` 中添加登录按钮和认证检查。

---

### 第三步：部署

#### 3.1 部署到 Vercel（推荐）

1. 将代码推送到 GitHub
2. 访问 [Vercel](https://vercel.com)
3. 导入 GitHub 仓库
4. 配置环境变量：
   - `VITE_SUPABASE_URL`
   - `VITE_SUPABASE_PUBLISHABLE_KEY`
5. 部署完成

#### 3.2 部署到 Netlify

1. 将代码推送到 GitHub
2. 访问 [Netlify](https://netlify.com)
3. 导入 GitHub 仓库
4. 配置环境变量
5. 构建命令：`npm run build`
6. 发布目录：`dist`
7. 部署完成

---

## 其他部署方案对比

### 方案二：自建后端 + 数据库

**优点：**
- 完全控制数据
- 无第三方依赖

**缺点：**
- 需要维护服务器
- 需要实现认证、授权、API
- 成本较高
- 开发周期长

**适用场景：** 大型应用、有专门运维团队

---

### 方案三：Firebase

**优点：**
- Google 提供，稳定可靠
- 实时数据库

**缺点：**
- 需要迁移现有 Supabase 代码
- 学习成本
- 定价可能较高

**适用场景：** 如果项目从零开始，可以考虑

---

## 成本估算

### Supabase 免费版
- ✅ 500MB 数据库空间
- ✅ 2GB 带宽/月
- ✅ 50,000 活跃用户/月
- ✅ 无限 API 请求

**对于中小型应用完全够用！**

### Vercel/Netlify 免费版
- ✅ 无限部署
- ✅ 自动 HTTPS
- ✅ CDN 加速
- ✅ 100GB 带宽/月

---

## 安全建议

1. ✅ **启用 RLS**：确保用户只能访问自己的数据
2. ✅ **使用 HTTPS**：Vercel/Netlify 自动提供
3. ✅ **环境变量**：不要将密钥提交到代码仓库
4. ✅ **密码策略**：要求用户使用强密码
5. ✅ **邮箱验证**：Supabase 默认启用

---

## 总结

**推荐使用 Supabase + Vercel 方案**，因为：

1. ✅ 项目已集成 Supabase，迁移成本低
2. ✅ 免费版足够使用
3. ✅ 部署简单，自动化程度高
4. ✅ 安全性好，RLS 自动处理权限
5. ✅ 扩展性强，未来可以轻松升级

需要我帮你实现具体的代码吗？
